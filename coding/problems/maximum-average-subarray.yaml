name: "Maximum Average Subarray I"
patterns: ["sliding-window"]
difficulty: "easy"
url: "https://leetcode.com/problems/maximum-average-subarray-i/"
problem: |
  You are given an integer array nums consisting of n elements, and an integer k.
  Find the contiguous subarray of length k that has the maximum average value and return this value.
  Any answer with a calculation error less than 10^-5 will be accepted.
flashcards:
  - question: "What is the time complexity of the brute-force approach for finding the maximum average subarray of length k?"
    answer: "O(n * k)"
  - question: "What is the time complexity of the sliding window approach for this problem?"
    answer: "O(n)"
  - question: "How does the sliding window technique improve efficiency for this problem?"
    answer: "Instead of recomputing the sum for every possible subarray of length k from scratch, the sliding window reuses the previous sum by subtracting the element that goes out of the window and adding the new element that comes into the window."
  - question: "What is/are the pattern(s) of the solution?"
    answer: "Sliding-window"
  - question: "How do you compute the average once you find the maximum sum of a subarray of length k?"
    answer: "Divide the maximum subarray sum by k to get the average."
  - question: "List the steps for the sliding window solution."
    answer: |
      1. Calculate the sum of the first k elements of the array.
      2. Let that sum be the current sum and also initialize max_sum with it.
      3. For each subsequent index i from k to n-1:
      4.   Update the current sum by subtracting nums[i-k] (element leaving the window) and adding nums[i] (new element entering the window).
      5.   Update max_sum = max(max_sum, current_sum).
      6. Return max_sum / k as the maximum average.